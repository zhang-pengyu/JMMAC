<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
   <html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <!-- IE Standards Mode -->
  <meta content="IE=edge" http-equiv="X-UA-Compatible"></meta>
  <!-- Favicon -->
  <link href="../images/vl_blue.ico" type="image/x-icon" rel="icon"></link>
  <link href="../images/vl_blue.ico" type="image/x-icon" rel="shortcut icon"></link>
  <!-- Page title -->
  <title>VLFeat - Documentation > C API</title>
  <!-- Stylesheets -->
  <link href="../vlfeat.css" type="text/css" rel="stylesheet"></link>
  <link href="../pygmentize.css" type="text/css" rel="stylesheet"></link>
  <style xml:space="preserve">
    /* fixes a conflict between Pygmentize and MathJax */
    .MathJax .mo, .MathJax .mi {color: inherit ! important}
  </style>
  <link rel="stylesheet" type="text/css" href="doxygen.css"></link>
<link rel="stylesheet" type="text/css" href="tabs.css"></link>
  <!-- Scripts-->
  <script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
  <!-- MathJax -->
  <script xml:space="preserve" type="text/x-mathjax-config">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      processEscapes: true,
    },
    TeX: {
      Macros: {
        balpha: '\\boldsymbol{\\alpha}',
        bc: '\\mathbf{c}',
        be: '\\mathbf{e}',
        bg: '\\mathbf{g}',
        bq: '\\mathbf{q}',
        bu: '\\mathbf{u}',
        bv: '\\mathbf{v}',
        bw: '\\mathbf{w}',
        bx: '\\mathbf{x}',
        by: '\\mathbf{y}',
        bz: '\\mathbf{z}',
        bsigma: '\\mathbf{\\sigma}',
        sign: '\\operatorname{sign}',
        diag: '\\operatorname{diag}',
        real: '\\mathbb{R}',
      },
      equationNumbers: { autoNumber: 'AMS' }
      }
    });
  </script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" xml:space="preserve" type="text/javascript"></script>
  <!-- Google Custom Search -->
  <script xml:space="preserve">
    (function() {
    var cx = '003215582122030917471:oq23albfeam';
    var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
    gcse.src = (document.location.protocol == 'https' ? 'https:' : 'http:') +
    '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
    })();
  </script>
  <!-- Google Analytics -->
  <script xml:space="preserve" type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-4936091-2']);
    _gaq.push(['_trackPageview']);
    (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
 </head>
 <!-- Body Start -->
 <body>
  <div id="header-section">
    <div id="header">
      <!-- Google CSE Search Box -->
      <div class="searchbox">
        <gcse:searchbox-only autoCompleteMaxCompletions="5" autoCompleteMatchType="any" resultsUrl="http://www.vlfeat.org/search.html"></gcse:searchbox-only>
      </div>
      <h1 id="id-16"><a shape="rect" href="../index.html" class="plain"><span id="vlfeat">VLFeat</span><span id="dotorg">.org</span></a></h1>
    </div>
    <div id="sidebar"> <!-- Navigation Start -->
      <ul>
<li><a href="../index.html">Home</a>
<ul>
<li><a href="../about.html">About</a>
</li>
<li><a href="../license.html">License</a>
</li>
</ul></li>
<li><a href="../download.html">Download</a>
<ul>
<li><a href="../install-matlab.html">Using from MATLAB</a>
</li>
<li><a href="../install-octave.html">Using from Octave</a>
</li>
<li><a href="../install-shell.html">Using from the command line</a>
</li>
<li><a href="../install-c.html">Using from C</a>
<ul>
<li><a href="../xcode.html">Xcode</a>
</li>
<li><a href="../vsexpress.html">Visual C++</a>
</li>
<li><a href="../gcc.html">g++</a>
</li>
</ul></li>
<li><a href="../compiling.html">Compiling</a>
<ul>
<li><a href="../compiling-unix.html">Compiling on UNIX-like platforms</a>
</li>
<li><a href="../compiling-windows.html">Compiling on Windows</a>
</li>
</ul></li>
</ul></li>
<li><a href="../overview/tut.html">Tutorials</a>
<ul>
<li><a href="../overview/frame.html">Local feature frames</a>
</li>
<li><a href="../overview/covdet.html">Covariant feature detectors</a>
</li>
<li><a href="../overview/hog.html">HOG features</a>
</li>
<li><a href="../overview/sift.html">SIFT detector and descriptor</a>
</li>
<li><a href="../overview/dsift.html">Dense SIFT</a>
</li>
<li><a href="../overview/liop.html">LIOP local descriptor</a>
</li>
<li><a href="../overview/mser.html">MSER feature detector</a>
</li>
<li><a href="../overview/imdisttf.html">Distance transform</a>
</li>
<li><a href="../overview/encodings.html">Fisher Vector and VLAD</a>
</li>
<li><a href="../overview/gmm.html">Gaussian Mixture Models</a>
</li>
<li><a href="../overview/kmeans.html">K-means clustering</a>
</li>
<li><a href="../overview/aib.html">Agglomerative Infromation Bottleneck</a>
</li>
<li><a href="../overview/quickshift.html">Quick shift superpixels</a>
</li>
<li><a href="../overview/slic.html">SLIC superpixels</a>
</li>
<li><a href="../overview/svm.html#tut.svm">Support Vector Machines (SVMs)</a>
</li>
<li><a href="../overview/kdtree.html">KD-trees and forests</a>
</li>
<li><a href="../overview/plots-rank.html">Plotting AP and ROC curves</a>
</li>
<li><a href="../overview/utils.html">Miscellaneous utilities</a>
</li>
<li><a href="../overview/ikm.html">Integer K-means</a>
</li>
<li><a href="../overview/hikm.html">Hierarchical integer k-means</a>
</li>
</ul></li>
<li><a href="../applications/apps.html">Applications</a>
</li>
<li class='active'><a href="../doc.html">Documentation</a>
<ul>
<li><a href="../matlab/matlab.html">MATLAB API</a>
</li>
<li class='active' class='activeLeaf'><a href="index.html">C API</a>
</li>
<li><a href="../man/man.html">Man pages</a>
</li>
</ul></li>
</ul>
    </div> <!-- sidebar -->
  </div>
  <div id="headbanner-section">
    <div id="headbanner">
      <span class='page'><a href="../doc.html">Documentation</a></span><span class='separator'>></span><span class='page'><a href="index.html">C API</a></span>
    </div>
  </div>
  <div id="content-section">
    <div id="content-wrapper">
      <div id="content">
      <!-- <pagestyle href="%pathto:root;api/tabs.css"/> -->
      <div class="doxygen">
<div id="top">
<div id="top">
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_8dd540b382164c224dfa1eb6e8a3add6.html">vl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">heap-def.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Heap preprocessor metaprogram.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="host_8h.html">host.h</a>&quot;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac2b59b9373be3df851dac7c594924a92"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a>&#160;&#160;&#160;<a class="el" href="heap-def_8h.html#a809b241c547ba76275bd10575086c3b2">VL_HEAP_type</a>*</td></tr>
<tr class="separator:ac2b59b9373be3df851dac7c594924a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d8f7e617493c4a73696983e1c360b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#ae0d8f7e617493c4a73696983e1c360b6">VL_HEAP_prefix</a>&#160;&#160;&#160;HeapObject</td></tr>
<tr class="separator:ae0d8f7e617493c4a73696983e1c360b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809b241c547ba76275bd10575086c3b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#a809b241c547ba76275bd10575086c3b2">VL_HEAP_type</a>&#160;&#160;&#160;HeapType</td></tr>
<tr class="separator:a809b241c547ba76275bd10575086c3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b59b9373be3df851dac7c594924a92"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a>&#160;&#160;&#160;HeapType*</td></tr>
<tr class="separator:ac2b59b9373be3df851dac7c594924a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b59b9373be3df851dac7c594924a92"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a>&#160;&#160;&#160;HeapType const*</td></tr>
<tr class="separator:ac2b59b9373be3df851dac7c594924a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7256f361601ba43113c862d9477f1d4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#a7256f361601ba43113c862d9477f1d4b">vl_heap_parent</a> (<a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> index)</td></tr>
<tr class="memdesc:a7256f361601ba43113c862d9477f1d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of parent node.  <a href="#a7256f361601ba43113c862d9477f1d4b">More...</a><br /></td></tr>
<tr class="separator:a7256f361601ba43113c862d9477f1d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b7f92afacd889da252d5a77fde5d05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#a95b7f92afacd889da252d5a77fde5d05">vl_heap_left_child</a> (<a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> index)</td></tr>
<tr class="memdesc:a95b7f92afacd889da252d5a77fde5d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of left child.  <a href="#a95b7f92afacd889da252d5a77fde5d05">More...</a><br /></td></tr>
<tr class="separator:a95b7f92afacd889da252d5a77fde5d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfa305e511251faa8cfb8b7114a31f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#aacfa305e511251faa8cfb8b7114a31f7">vl_heap_right_child</a> (<a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> index)</td></tr>
<tr class="memdesc:aacfa305e511251faa8cfb8b7114a31f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of right child.  <a href="#aacfa305e511251faa8cfb8b7114a31f7">More...</a><br /></td></tr>
<tr class="separator:aacfa305e511251faa8cfb8b7114a31f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af926f2b2ea17e5adcf6ab144d87f96e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="heap-def_8h.html#a809b241c547ba76275bd10575086c3b2">VL_HEAP_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#af926f2b2ea17e5adcf6ab144d87f96e2">VL_HEAP_cmp</a> (VL_HEAP_array_const array, <a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> indexA, <a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> indexB)</td></tr>
<tr class="memdesc:af926f2b2ea17e5adcf6ab144d87f96e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two heap elements.  <a href="#af926f2b2ea17e5adcf6ab144d87f96e2">More...</a><br /></td></tr>
<tr class="separator:af926f2b2ea17e5adcf6ab144d87f96e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f32c850484c8824785a17e9d93272b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#a23f32c850484c8824785a17e9d93272b">VL_HEAP_swap</a> (<a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a> array, <a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> indexA, <a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> indexB)</td></tr>
<tr class="memdesc:a23f32c850484c8824785a17e9d93272b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two heap elements.  <a href="#a23f32c850484c8824785a17e9d93272b">More...</a><br /></td></tr>
<tr class="separator:a23f32c850484c8824785a17e9d93272b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4d40e0b2309f0d897a8b1e9a55d726"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#a8c4d40e0b2309f0d897a8b1e9a55d726">VL_HEAP_up</a> (<a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a> array, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> heapSize, <a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> index)</td></tr>
<tr class="memdesc:a8c4d40e0b2309f0d897a8b1e9a55d726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap up operation.  <a href="#a8c4d40e0b2309f0d897a8b1e9a55d726">More...</a><br /></td></tr>
<tr class="separator:a8c4d40e0b2309f0d897a8b1e9a55d726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd0336086a1762e0ac2cace28c9656a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#affd0336086a1762e0ac2cace28c9656a">VL_HEAP_down</a> (<a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a> array, <a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> index)</td></tr>
<tr class="memdesc:affd0336086a1762e0ac2cace28c9656a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap down operation.  <a href="#affd0336086a1762e0ac2cace28c9656a">More...</a><br /></td></tr>
<tr class="separator:affd0336086a1762e0ac2cace28c9656a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d30a74d7d51d3ed4c9f3e35ef6c638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#ab8d30a74d7d51d3ed4c9f3e35ef6c638">VL_HEAP_push</a> (<a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a> array, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> *heapSize)</td></tr>
<tr class="memdesc:ab8d30a74d7d51d3ed4c9f3e35ef6c638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap push operation.  <a href="#ab8d30a74d7d51d3ed4c9f3e35ef6c638">More...</a><br /></td></tr>
<tr class="separator:ab8d30a74d7d51d3ed4c9f3e35ef6c638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e07a24d045fbc08853213bc84be5ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#ac9e07a24d045fbc08853213bc84be5ea">VL_HEAP_pop</a> (<a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a> array, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> *heapSize)</td></tr>
<tr class="memdesc:ac9e07a24d045fbc08853213bc84be5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap pop operation.  <a href="#ac9e07a24d045fbc08853213bc84be5ea">More...</a><br /></td></tr>
<tr class="separator:ac9e07a24d045fbc08853213bc84be5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6718e132e6bfabc177ca2f5115dd6452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap-def_8h.html#a6718e132e6bfabc177ca2f5115dd6452">VL_HEAP_update</a> (<a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a> array, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> heapSize, <a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> index)</td></tr>
<tr class="memdesc:a6718e132e6bfabc177ca2f5115dd6452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap update operation.  <a href="#a6718e132e6bfabc177ca2f5115dd6452">More...</a><br /></td></tr>
<tr class="separator:a6718e132e6bfabc177ca2f5115dd6452"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Andrea Vedaldi</dd></dl>
<p>A heap organizes an array of objects in a priority queue. This module is a template metaprogram that defines heap operations on array of generic objects, or even generic object containers.</p>
<ul>
<li><a class="el" href="heap-def_8h.html#heap-def-overview">Overview</a><ul>
<li><a class="el" href="heap-def_8h.html#heap-def-overview-general">General usage</a></li>
</ul>
</li>
<li><a class="el" href="heap-def_8h.html#heap-def-tech">Technical details</a></li>
</ul>
<h1><a class="anchor" id="heap-def-overview"></a>
Overview</h1>
<p>To use <a class="el" href="heap-def_8h.html">heap-def.h</a> one must specify at least a prefix and the data type for the heap elements:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define VL_HEAP_prefix  my_heap</span></div><div class="line"><span class="preprocessor">#define VL_HEAP_type    float</span></div><div class="line"><span class="preprocessor">#include &lt;vl/heap-def.h&gt;</span></div></div><!-- fragment --><p>This code fragment defines a number of functions prefixed by <a class="el" href="heap-def_8h.html#ae0d8f7e617493c4a73696983e1c360b6">VL_HEAP_prefix</a>, such as <code>my_heap_push</code> (<a class="el" href="heap-def_8h.html#ab8d30a74d7d51d3ed4c9f3e35ef6c638" title="Heap push operation. ">VL_HEAP_push</a>) and <code>my_heap_pop</code> (<a class="el" href="heap-def_8h.html#ac9e07a24d045fbc08853213bc84be5ea" title="Heap pop operation. ">VL_HEAP_pop</a>), that implement the heap operations. These functions operate on an array that has type <a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a>. By default, this is defined to be:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define VL_HEAP_array VL_HEAP_type*</span></div><div class="line"><span class="preprocessor">#define VL_HEAP_array_const VL_HEAP_type const*</span></div></div><!-- fragment --><p>The array itself is accessed uniquely by means of two functions:</p>
<ul>
<li><a class="el" href="heap-def_8h.html#af926f2b2ea17e5adcf6ab144d87f96e2" title="Compare two heap elements. ">VL_HEAP_cmp</a>, that compares two array elements. The default implementation assumes that <a class="el" href="heap-def_8h.html#a809b241c547ba76275bd10575086c3b2">VL_HEAP_type</a> is numeric.</li>
<li><a class="el" href="heap-def_8h.html#a23f32c850484c8824785a17e9d93272b" title="Swap two heap elements. ">VL_HEAP_swap</a>, that swaps two array elements. The default implementation assumes that <a class="el" href="heap-def_8h.html#a809b241c547ba76275bd10575086c3b2">VL_HEAP_type</a> can be copied by the <code>=</code> operator.</li>
</ul>
<p>The heap state is a integer <code>numElements</code> (of type <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555" title="Unsigned integer holding the size of a memory block. ">vl_size</a>) counting the number of elements of the array that are currently part of the heap and the content of the first <code>numElements</code> elements of the array. The portion of the array that constitutes the heap satisfies a certain invariant property (heap property, <a class="el" href="heap-def_8h.html#heap-def-tech">Technical details</a>). From a user viewpoint, the most important consequence is that the first element of the array (the one of index 0) is also the smallest (according to <a class="el" href="heap-def_8h.html#af926f2b2ea17e5adcf6ab144d87f96e2" title="Compare two heap elements. ">VL_HEAP_cmp</a>).</p>
<p>Elements are added to the heap by <a class="el" href="heap-def_8h.html#ab8d30a74d7d51d3ed4c9f3e35ef6c638" title="Heap push operation. ">VL_HEAP_push</a> and removed from the heap by <a class="el" href="heap-def_8h.html#ac9e07a24d045fbc08853213bc84be5ea" title="Heap pop operation. ">VL_HEAP_pop</a>. A push operation adds to the heap the array element immediately after the last element already in the heap (i.e. the element of index <code>numElements</code>) and increases the number of heap elements <code>numElements</code>. Elements in the heap are swapped as required in order to maintain the heap consistency. Similarly, a pop operation removes the first (smaller) element from the heap and decreases the number of heap elements <code>numElements</code>.</p>
<p>The values of nodes currently in the heap can be updated by <a class="el" href="heap-def_8h.html#a6718e132e6bfabc177ca2f5115dd6452" title="Heap update operation. ">VL_HEAP_update</a>. Notice however that using this function requires knowing the index of the element that needs to be updated up to the swapping operations that the heap performs to maintain consistency. Typically, this requires redefining <a class="el" href="heap-def_8h.html#a23f32c850484c8824785a17e9d93272b" title="Swap two heap elements. ">VL_HEAP_swap</a> to keep track of such changes (<a class="el" href="heap-def_8h.html#heap-def-overview-general">General usage</a>).</p>
<h2><a class="anchor" id="heap-def-overview-general"></a>
General usage</h2>
<p>The heap container may be mapped to any type by reimplementing <a class="el" href="heap-def_8h.html#af926f2b2ea17e5adcf6ab144d87f96e2" title="Compare two heap elements. ">VL_HEAP_cmp</a> and <a class="el" href="heap-def_8h.html#a23f32c850484c8824785a17e9d93272b" title="Swap two heap elements. ">VL_HEAP_swap</a> explicitly. For instance the following code redefines <a class="el" href="heap-def_8h.html#af926f2b2ea17e5adcf6ab144d87f96e2" title="Compare two heap elements. ">VL_HEAP_cmp</a> to deal with the case in which the heap is an array of structures:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_S { <span class="keywordtype">int</span> x ; } S ;</div><div class="line"><span class="keywordtype">int</span> s_cmp (S <span class="keyword">const</span> * v, <a class="code" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> a, <a class="code" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> b) {</div><div class="line">  <span class="keywordflow">return</span> v[a].x - v[b].x ;</div><div class="line">}</div><div class="line"><span class="preprocessor">#define VL_HEAP_prefix  s_heap</span></div><div class="line"><span class="preprocessor">#define VL_HEAP_type    S</span></div><div class="line"><span class="preprocessor">#define VL_HEAP_cmp     s_cmp</span></div><div class="line"><span class="preprocessor">#include &lt;vl/heap-def.h&gt;</span></div></div><!-- fragment --><p>In the following example, the heap itself is an arbitrary structure:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_H { <span class="keywordtype">int</span>* array ; } H ;</div><div class="line"><span class="keywordtype">int</span> h_cmp (H <span class="keyword">const</span> * h, <a class="code" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> a, <a class="code" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> b) {</div><div class="line">  <span class="keywordflow">return</span> h-&gt;array[a] - h-&gt;array[b] ;</div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> h_swap (H * h, <a class="code" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> a, <a class="code" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> b) {</div><div class="line">  <span class="keywordtype">int</span> t = h-&gt;array[a] ;</div><div class="line">  h-&gt;array[a] = h-&gt;array[b] ;</div><div class="line">  h-&gt;array[b] = t ;</div><div class="line">}</div><div class="line"><span class="preprocessor">#define VL_HEAP_prefix  h_heap</span></div><div class="line"><span class="preprocessor">#define VL_HEAP_swap    h_swap</span></div><div class="line"><span class="preprocessor">#define VL_HEAP_cmp     h_cmp</span></div><div class="line"><span class="preprocessor">#include &lt;vl/heap-def.h&gt;</span></div></div><!-- fragment --><h1><a class="anchor" id="heap-def-tech"></a>
Technical details</h1>
<p>The heap is organised as a binary tree with the property (<em>heap property</em>) that any node is not larger than any of its children. In particular, the root is the smallest node.</p>
<p><a class="el" href="heap-def_8h.html">heap-def.h</a> uses the standard binary tree representation as a linear array. Tree nodes are mapped to array elements as follows: <code>array[0]</code> corresponds to the root, <code>array[1]</code> and <code>array[2]</code> to the root left and right children and so on. In this way, the tree structure is fully specified by the total number of nodes <code>N</code>.</p>
<p>Assuming that the heap has <code>N</code> nodes (from <code>array[0]</code> to <code>array[N-1]</code>), adding the node <code>array[N]</code> to the heap is done by a <em>push down</em> operation: if the node <code>array[N]</code> is smaller than its parent (violating the heap property) it is pushed down by swapping it with the parent, and so on recursively.</p>
<p>Removing the smallest element <code>array[0]</code> with an heap of <code>N</code> nodes is done by swapping <code>array[0]</code> with <code>array[N-1]</code>. If then <code>array[0]</code> is larger than any of its children, it is swapped with the smallest of the two and so on recursively (<em>push up</em> operation).</p>
<p>Restoring the heap property after an element <code>array[i]</code> has been modified can be done by a push up or push down operation on that node. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac2b59b9373be3df851dac7c594924a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b59b9373be3df851dac7c594924a92">&#9670;&nbsp;</a></span>VL_HEAP_array <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL_HEAP_array&#160;&#160;&#160;<a class="el" href="heap-def_8h.html#a809b241c547ba76275bd10575086c3b2">VL_HEAP_type</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data type of the heap container</p>
<p>Const data type of the heap container </p>

</div>
</div>
<a id="ac2b59b9373be3df851dac7c594924a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b59b9373be3df851dac7c594924a92">&#9670;&nbsp;</a></span>VL_HEAP_array <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL_HEAP_array&#160;&#160;&#160;HeapType*</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data type of the heap container</p>
<p>Const data type of the heap container </p>

</div>
</div>
<a id="ac2b59b9373be3df851dac7c594924a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b59b9373be3df851dac7c594924a92">&#9670;&nbsp;</a></span>VL_HEAP_array <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL_HEAP_array&#160;&#160;&#160;HeapType const*</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data type of the heap container</p>
<p>Const data type of the heap container </p>

</div>
</div>
<a id="ae0d8f7e617493c4a73696983e1c360b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d8f7e617493c4a73696983e1c360b6">&#9670;&nbsp;</a></span>VL_HEAP_prefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL_HEAP_prefix&#160;&#160;&#160;HeapObject</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prefix of the heap functions </p>

</div>
</div>
<a id="a809b241c547ba76275bd10575086c3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809b241c547ba76275bd10575086c3b2">&#9670;&nbsp;</a></span>VL_HEAP_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL_HEAP_type&#160;&#160;&#160;HeapType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data type of the heap elements </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af926f2b2ea17e5adcf6ab144d87f96e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af926f2b2ea17e5adcf6ab144d87f96e2">&#9670;&nbsp;</a></span>VL_HEAP_cmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="heap-def_8h.html#a809b241c547ba76275bd10575086c3b2">VL_HEAP_type</a> VL_HEAP_cmp </td>
          <td>(</td>
          <td class="paramtype">VL_HEAP_array_const&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td>
          <td class="paramname"><em>indexA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td>
          <td class="paramname"><em>indexB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>heap array. </td></tr>
    <tr><td class="paramname">indexA</td><td>index of the first element <code>A</code> to compare. </td></tr>
    <tr><td class="paramname">indexB</td><td>index of the second element <code>B</code> to comapre. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a negative number if <code>A&lt;B</code>, 0 if <code>A==B</code>, and a positive number if if <code>A&gt;B</code>. </dd></dl>

</div>
</div>
<a id="affd0336086a1762e0ac2cace28c9656a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd0336086a1762e0ac2cace28c9656a">&#9670;&nbsp;</a></span>VL_HEAP_down()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VL_HEAP_down </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a>&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>pointer to the heap node array. </td></tr>
    <tr><td class="paramname">index</td><td>index of the node to push up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95b7f92afacd889da252d5a77fde5d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b7f92afacd889da252d5a77fde5d05">&#9670;&nbsp;</a></span>vl_heap_left_child()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> vl_heap_left_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>a node index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the left child. </dd></dl>

</div>
</div>
<a id="a7256f361601ba43113c862d9477f1d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7256f361601ba43113c862d9477f1d4b">&#9670;&nbsp;</a></span>vl_heap_parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> vl_heap_parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>a node index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the parent node. </dd></dl>

</div>
</div>
<a id="ac9e07a24d045fbc08853213bc84be5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e07a24d045fbc08853213bc84be5ea">&#9670;&nbsp;</a></span>VL_HEAP_pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> VL_HEAP_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a>&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> *&#160;</td>
          <td class="paramname"><em>heapSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>pointer to the heap array. </td></tr>
    <tr><td class="paramname">heapSize</td><td>(in/out) size of the heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the popped element.</dd></dl>
<p>The function extracts from the heap the element of index 0 (the smallest element) and decreases <code>heapSize</code>.</p>
<p>The element extracted is moved as the first element after the heap end (thus it has index <code>heapSize</code>). For convenience, this index is returned by the function.</p>
<p>Popping from an empty heap is undefined. </p>

</div>
</div>
<a id="ab8d30a74d7d51d3ed4c9f3e35ef6c638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d30a74d7d51d3ed4c9f3e35ef6c638">&#9670;&nbsp;</a></span>VL_HEAP_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VL_HEAP_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a>&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> *&#160;</td>
          <td class="paramname"><em>heapSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>pointer to the heap array. </td></tr>
    <tr><td class="paramname">heapSize</td><td>(in/out) size of the heap.</td></tr>
  </table>
  </dd>
</dl>
<p>The function adds to the heap the element of index <code>heapSize</code> and increments <code>heapSize</code>. </p>

</div>
</div>
<a id="aacfa305e511251faa8cfb8b7114a31f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfa305e511251faa8cfb8b7114a31f7">&#9670;&nbsp;</a></span>vl_heap_right_child()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a> vl_heap_right_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>a node index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the right child. </dd></dl>

</div>
</div>
<a id="a23f32c850484c8824785a17e9d93272b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f32c850484c8824785a17e9d93272b">&#9670;&nbsp;</a></span>VL_HEAP_swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VL_HEAP_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a>&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td>
          <td class="paramname"><em>indexA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td>
          <td class="paramname"><em>indexB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>array of nodes. </td></tr>
    <tr><td class="paramname">array</td><td>heap array. </td></tr>
    <tr><td class="paramname">indexA</td><td>index of the first node to swap. </td></tr>
    <tr><td class="paramname">indexB</td><td>index of the second node to swap.</td></tr>
  </table>
  </dd>
</dl>
<p>The function swaps the two heap elements <em>a</em> and @ b. The function uses a temporary element and the copy operator, which must be well defined for the heap elements. </p>

</div>
</div>
<a id="a8c4d40e0b2309f0d897a8b1e9a55d726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4d40e0b2309f0d897a8b1e9a55d726">&#9670;&nbsp;</a></span>VL_HEAP_up()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VL_HEAP_up </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a>&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"><em>heapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>pointer to the heap array. </td></tr>
    <tr><td class="paramname">heapSize</td><td>size of the heap. </td></tr>
    <tr><td class="paramname">index</td><td>index of the node to push up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6718e132e6bfabc177ca2f5115dd6452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6718e132e6bfabc177ca2f5115dd6452">&#9670;&nbsp;</a></span>VL_HEAP_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VL_HEAP_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="heap-def_8h.html#ac2b59b9373be3df851dac7c594924a92">VL_HEAP_array</a>&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"><em>heapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#ac13bd3cc913e1da576e189a3ec8d66fc">vl_uindex</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>pointer to the heap array. </td></tr>
    <tr><td class="paramname">heapSize</td><td>size of the heap. </td></tr>
    <tr><td class="paramname">index</td><td>index of the node to update.</td></tr>
  </table>
  </dd>
</dl>
<p>The function updates the heap to account for a change to the element of index <code>index</code> in the heap.</p>
<p>Notice that using this function requires knowing the index of the heap index of element that was changed. Since the heap swaps elements in the array, this is in general different from the index that that element had originally. </p>

</div>
</div>
</div><!-- contents -->
        <!-- Doc Here -->
      </div>
      </div>
      <div class="clear">&nbsp;</div>
    </div>
  </div> <!-- content-section -->
  <div id="footer-section">
    <div id="footer">
      &copy; 2007-14,18 The VLFeat Authors
    </div> <!-- footer -->
  </div> <!-- footer section -->
 </body>
 <!-- Body ends -->
</html>
